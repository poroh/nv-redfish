// SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Rust code generator for compiled structures.
//!
//! Following rules are applied for generation.
//!
//! Namespaces:
//!  - Each namespace is generated in each own module
//!  - Camel case identifieds in namespaces are converted to snake case.
//!  - If namespace more than one ids then submodules are generated in according to namespace.
//!

/// Mod name
pub mod mod_name;

/// Documentation generation
pub mod doc;

/// Configuration of generation
pub mod config;

/// Short type name (only name)
pub mod type_name;

/// Full type name (name with fully qualified path)
pub mod full_type_name;

/// Property name for structs
pub mod property_name;

/// Mod definition
pub mod mod_def;

/// Struct definition
pub mod struct_def;

/// Simple types definitions
pub mod simple_def;

use crate::compiler::Compiled;
use crate::compiler::QualifiedName;
use proc_macro2::TokenStream;
use quote::quote;
use std::fmt::Display;
use std::fmt::Formatter;
use std::fmt::Result as FmtResult;

/// Reexport of `ModName`.
pub type ModName<'a> = mod_name::ModName<'a>;
/// Reexport of `ModDef`.
pub type ModDef<'a> = mod_def::ModDef<'a>;
/// Reexport of `StructDef`.
pub type StructDef<'a> = struct_def::StructDef<'a>;
/// Reexport of `SimpleDef`.
pub type SimpleDef<'a> = simple_def::SimpleDef<'a>;
/// Reexport of `Config`.
pub type Config = config::Config;
/// Reexport of `TypeName`.
pub type TypeName<'a> = type_name::TypeName<'a>;
/// Reexport of `FullTypeName`.
pub type FullTypeName<'a, 'config> = full_type_name::FullTypeName<'a, 'config>;
/// Reexport of `PropertyName`.
pub type PropertyName<'a> = property_name::PropertyName<'a>;

/// Errors that can occur during code generation.
pub enum Error<'a> {
    BaseTypeConflict,
    NameConflict,
    CreateStruct(QualifiedName<'a>, Box<Error<'a>>),
    CreateSimplType(QualifiedName<'a>, Box<Error<'a>>),
}

impl Display for Error<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            Self::BaseTypeConflict => write!(
                f,
                "derivation property name conflict, see `base_type_prop_name` configuration parameter"
            ),
            Self::NameConflict => write!(f, "name conflict"),
            Self::CreateStruct(id, err) => write!(f, "while create struct {id}\n{err}"),
            Self::CreateSimplType(id, err) => write!(f, "while create simple type {id}\n{err}"),
        }
    }
}

pub struct RustGenerator<'a> {
    root: ModDef<'a>,
    config: Config,
}

impl<'a> RustGenerator<'a> {
    /// # Errors
    ///
    /// Returns error if Rust code cannot be generated by the compiled
    /// data structure.
    pub fn new(compiled: Compiled<'a>, config: Config) -> Result<Self, Error<'a>> {
        let root = compiled
            .complex_types
            .into_iter()
            .try_fold(ModDef::default(), |m, (_, ct)| {
                m.add_complex_type(ct, &config)
            })?;
        let root = compiled
            .entity_types
            .into_iter()
            .try_fold(root, |m, (_, et)| m.add_entity_type(et, &config))?;
        let root = compiled
            .simple_types
            .into_iter()
            .try_fold(root, |m, (_, st)| m.add_simple_type(st))?;
        Ok(Self { root, config })
    }
}

impl RustGenerator<'_> {
    #[must_use]
    pub fn generate(self) -> TokenStream {
        let mut tokens = TokenStream::new();
        tokens.extend(quote! {
            //! This code is automatically generated by CSDL
            //! generator. DO NOT EDIT!
            //!
            use serde::Deserialize;

            pub trait EntityType {
                fn id(&self) -> &String;
            }

            #[derive(Deserialize, Debug)]
            pub struct Reference {
                #[serde(rename="@odata.id")]
                pub odata_id: String,
            }

            #[derive(Deserialize, Debug)]
            #[serde(untagged)]
            pub enum NavProperty<T: EntityType> {
                Expanded(T),
                Reference(Reference),
            }

            impl<T: EntityType> NavProperty<T> {
                pub fn id(&self) -> &String {
                    match self {
                        Self::Reference(v) => &v.odata_id,
                        Self::Expanded(v) => v.id()
                    }
                }
            }

            pub mod edm {
                //! This module is hardcoded in compiler. If you want
                //! to change it you need to change source code of
                //! generator.
                //!
                /// Mapping of Edm.Boolean type
                pub type Boolean = bool;
                /// Mapping of DateTimeOffset type
                pub type DateTimeOffset = String;
                /// Mapping of Edm.Decimal
                pub type Decimal = f64;
                /// Mapping of Duration type
                pub type Duration = String;
                /// Mapping of Guid type
                pub type Guid = String;
                /// Mapping of Edm.Int64 type
                pub type Int64 = i64;
                /// Mapping of Edm.String type
                pub type String = ::std::string::String;
            }
        });
        self.root.generate(&mut tokens, &self.config);
        tokens
    }
}
